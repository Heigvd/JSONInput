{"version":3,"file":"index.es2015.js","sources":["../src/Store/index.tsx","../src/Comps/defaultWidgets.tsx","../src/Comps/Fields/Widget.tsx","../src/Utils/customValidator.ts","../src/Store/actions.ts","../src/Comps/Decorators/validator.tsx","../src/Comps/Fields/Object.tsx","../src/Comps/Fields/String.tsx","../src/Comps/Fields/Number.tsx","../src/Comps/Fields/Boolean.tsx","../src/Comps/Fields/Array.tsx","../src/Comps/Fields/index.tsx","../src/Comps/Fields/Undefined.tsx","../src/Utils/infer.ts","../src/Comps/Decorators/fromDefaultValue.tsx","../src/Comps/SchemaType.tsx","../src/Comps/Decorators/visible.tsx","../src/Comps/Decorators/inference.tsx","../src/Comps/Container.tsx"],"sourcesContent":["import * as React from 'react';\nimport immer, { Immutable } from 'immer';\n\ninterface StoreProps {\n  value?: {};\n  schema: {};\n  context?: {};\n  onValueChange: (value: {}) => void;\n  children: (props: {\n    dispatch: (\n      action: (state: any, ...extraArgs: any[]) => void,\n      ...args: any[]\n    ) => void;\n    schema: {};\n    value: {};\n    status: {};\n    context?: {};\n  }) => JSX.Element;\n}\nexport interface FormContext {\n  value: Immutable<{}> | undefined | null;\n  schema: {};\n  context: {};\n  status: {};\n}\nconst FormContext = React.createContext<FormContext>({\n  value: undefined,\n  schema: {},\n  context: {},\n  status: {},\n});\nexport const FormConsumer = FormContext.Consumer;\nexport class Store extends React.Component<StoreProps> {\n  readonly state = {\n    schema: {},\n    value: {},\n    extValue: {},\n    status: {},\n    context: {},\n    oldProps: {},\n  };\n  static getDerivedStateFromProps(\n    nextProps: StoreProps,\n    state: {\n      schema: {};\n      value: {};\n      status: {};\n      context: {},\n      oldProps: StoreProps;\n      extValue: {} | undefined;\n    },\n  ) {\n    if (state.oldProps !== nextProps) {\n      const ret: Partial<typeof Store.prototype.state> = {\n        value: nextProps.value,\n        schema: nextProps.schema,\n        context: nextProps.context,\n        oldProps: nextProps,\n      };\n      if (nextProps.value !== state.extValue) {\n        ret.status = {};\n        ret.extValue = nextProps.value;\n      }\n      return ret;\n    }\n    return null;\n  }\n  dispatch = (\n    action: (state: any, ...extraArgs: any[]) => void,\n    ...args: any[]\n  ) => {\n    this.setState(prevState => {\n      return (immer(action) as (state: any, ...extraArgs: any[]) => any)(\n        prevState,\n        ...args,\n      );\n    });\n  };\n  shouldComponentUpdate(nextProps: any, nextState: any) {\n    return this.state !== nextState;\n  }\n  componentDidUpdate(prevProps: StoreProps, prevState: { value: {} }) {\n    if (\n      this.state.value !== prevState.value &&\n      // This is not an update due to a props change.\n      this.props.value === prevProps.value\n    ) {\n      const extValue = this.state.value;\n      this.setState({ extValue }, () => this.props.onValueChange(extValue));\n    }\n  }\n  render() {\n    const { schema, value, status, context } = this.state;\n    const cloneValue =\n      value != null ? JSON.parse(JSON.stringify(value)) : value;\n    return (\n      <FormContext.Provider\n        value={{\n          schema,\n          value: cloneValue,\n          context,\n          status,\n        }}\n      >\n        {this.props.children({\n          schema,\n          value: cloneValue,\n          status,\n          context,\n          dispatch: this.dispatch,\n        })}\n      </FormContext.Provider>\n    );\n  }\n}\n","import * as React from 'react';\nimport { WidgetProps } from '../../typings/types';\n\nexport type WidgetMap = {\n  [key: string]: React.ComponentType<WidgetProps>;\n};\n\nfunction undefinedWidgetFactory(type: string) {\n  return function UndefinedWidget() {\n    return <span>{`Widget for '${type}' was not defined`}</span>;\n  };\n}\nlet DefaultWidget: WidgetMap = {};\n\nfunction defaultWidget(type: string) {\n  return DefaultWidget[type] || undefinedWidgetFactory(type);\n}\n\nfunction setDefaultWidgets(obj: WidgetMap) {\n  DefaultWidget = Object.assign({}, DefaultWidget, obj);\n}\n\nexport { defaultWidget, setDefaultWidgets };\n","import * as React from 'react';\nimport { Schema, TYPESTRING } from '../../../typings/types';\nimport { FormContext } from '../../Store';\nimport { defaultWidget } from '../defaultWidgets';\n\ntype Props = {\n  value?: {};\n  schema: Schema;\n  context?: {},\n  editKey: string;\n  __tree: FormContext;\n  onChange: (value: any) => void;\n  errorMessage?: string[];\n  path: string[];\n  children?: JSX.Element[];\n  addKey?: (key: string, value?: unknown) => void;\n  removeKey?: (key: string) => void;\n  alterKey?: (key: string, newKey: string) => void;\n  onChildAdd?: () => void;\n  onChildRemove?: (index: number) => void;\n};\n\nconst EMPTYOBJECT = {};\nfunction Widget<P extends Props>(props: P) {\n  const {\n    value,\n    schema,\n    schema: { view },\n    __tree: { value: formVal },\n    children,\n    editKey,\n    path,\n    onChange,\n    onChildAdd,\n    onChildRemove,\n    addKey,\n    removeKey,\n    alterKey,\n    errorMessage,\n    context,\n  } = props;\n  const forwardProps = {\n    value,\n    schema,\n    children,\n    editKey,\n    path,\n    onChange,\n    onChildAdd,\n    onChildRemove,\n    addKey,\n    removeKey,\n    alterKey,\n    errorMessage,\n    context,\n  };\n  if (view) {\n    const { type } = view;\n    if (typeof type === 'string') {\n      const Wdgt = defaultWidget(type);\n      return <Wdgt {...forwardProps} formValue={formVal} view={view} />;\n    }\n    if (typeof type === 'function') {\n      const Type = type;\n      return <Type {...forwardProps} formValue={formVal} view={view} />;\n    }\n  }\n  let renderType = Array.isArray(schema.type)\n    ? (schema.type as TYPESTRING[]).find(t => t !== 'null')\n    : schema.type;\n  let Wdgt;\n  if (renderType === undefined) {\n    Wdgt = defaultWidget('undefinedType');\n  } else {\n    Wdgt = defaultWidget(renderType);\n  }\n  return (\n    <Wdgt\n      {...forwardProps}\n      formValue={formVal}\n      view={view || EMPTYOBJECT}\n    />\n  );\n}\n\nexport default Widget;\n","import * as jsonschema from 'jsonschema';\nimport { ValidatorResult } from 'jsonschema/lib';\nimport { Schema, ErrorFn } from '../../typings/types';\n\nconst customValidator = new jsonschema.Validator();\ncustomValidator.attributes.errored = function validateErrored(\n  instance: {},\n  schema: { errored?: ErrorFn },\n  options: { formValue: {}; ctx: { basePath?: string[] } },\n  ctx: { propertyPath: String },\n) {\n  if (typeof schema.errored !== 'function') {\n    throw new jsonschema.SchemaError('\"errored\" expects a function');\n  }\n  const path = (options.ctx.basePath || []).concat(\n    ctx.propertyPath.split('.').slice(1),\n  );\n  const msg = schema.errored(instance, options.formValue, path);\n  if (msg) {\n    return msg;\n  }\n  return undefined;\n};\nfunction validate(\n  value: {} | undefined | null,\n  schema: Schema,\n  formValue?: {} | undefined | null,\n  basePath?: string[],\n): ValidatorResult {\n  return customValidator.validate(value, schema, {\n    formValue: formValue || {},\n    ctx: {\n      basePath,\n    },\n  });\n}\n\nexport default validate;\n","import { ValidationError } from 'jsonschema/lib';\nimport { get, unset, setWith } from 'lodash-es';\n\nconst VALUE = 'value';\nconst STATUS = 'status';\nconst STATE = '$$$state';\nconst ERRORS = '$$$errors';\nconst NO_ERRORS: string[] = [];\n\nfunction setErrors(state: any, path: string[] = [], errors: string[]) {\n  const errorPath = [STATUS].concat(path).concat([ERRORS]);\n  setWith(state, errorPath, errors, Object);\n}\nexport function setValidationErrors(\n  state: any,\n  path: string[] = [],\n  errors: ValidationError[],\n) {\n  const errorMap = new Map<string, string[]>();\n  // Collect each error associated with a given path\n  errors.forEach(error => {\n    const errors = errorMap.get(error.property) || [];\n    errors.push(error.message); // Add new error\n    errorMap.set(error.property, errors);\n  });\n  setErrors(state, path, NO_ERRORS);\n  errorMap.forEach((value, key) => {\n    setErrors(\n      state,\n      path.concat(\n        key\n          .split(/\\.|\\[|\\]/)\n          .filter(x => x !== '')\n          .slice(1),\n      ),\n      value,\n    );\n  });\n}\n\n/**\n * Update a value in the tree\n *\n * @param state the tree\n * @param path path's value to update\n * @param value value to set\n * @param errors errors relative to the value\n */\nexport function update(\n  state: any,\n  path: string[] = [],\n  value: {},\n  errors: ValidationError[],\n) {\n  const statusPath = [STATUS].concat(path);\n  setWith(state, [VALUE].concat(path), value, Object);\n  setWith(state, statusPath.concat([STATE]), 'dirty', Object);\n  setValidationErrors(state, path, errors);\n}\n\nexport function setDefaultValue(state: any, path: string[] = [], value: {}) {\n  update(state, path, value, []);\n  setWith(state, [STATUS].concat(path).concat([STATE]), 'pristine', Object);\n}\n\n/**\n * Unset given path\n * @param state the tree\n * @param path path to value\n */\nexport function destroy(state: any, path: string[] = []) {\n  try {\n    unset(state, [STATUS].concat(path));\n  } catch (e) {\n    // Maybe already destroyed\n  }\n}\n\n// GETTERS, DO NOT USE with a dispatcher\n\nexport function getErrors(state: any, path: string[] = []) {\n  return get(state, [STATUS].concat(path).concat([ERRORS])) || NO_ERRORS;\n}\n","import * as React from 'react';\nimport validate from './../../Utils/customValidator';\nimport { getErrors } from '../../Store/actions';\n\nimport { Schema, Action } from '../../../typings/types';\nimport { ValidationError } from 'jsonschema/lib';\nimport { FormConsumer } from '../../Store';\n\ntype Props = {\n  schema: Schema;\n  value?: any;\n  dispatch: (action: Action, ...args: {}[]) => any;\n  path: string[];\n  onChange: (value: any, errors?: ValidationError[]) => void;\n};\n\nfunction validated<P extends Props>(\n  Comp: React.ComponentType<P & { errorMessage?: string[] }>,\n) {\n  class Validator extends React.Component<P & { __tree: any; path: string[] }> {\n    onChange = (val?: {}) => {\n      const validation = validate(\n        val,\n        this.props.schema,\n        this.props.__tree.value,\n        this.props.path,\n      );\n      this.props.onChange(val, validation.errors);\n    };\n    shouldComponentUpdate(nextProps: P & { __tree: any }) {\n      return (\n        this.props.value !== nextProps.value ||\n        this.props.schema !== nextProps.schema ||\n        getErrors(this.props.__tree, this.props.path) !==\n          getErrors(nextProps.__tree, nextProps.path)\n      );\n    }\n    render() {\n      const { path } = this.props;\n      return (\n        <Comp\n          {...this.props}\n          errorMessage={getErrors(this.props.__tree, path)}\n          onChange={this.onChange}\n        />\n      );\n    }\n  }\n  return (p: P) => {\n    return (\n      <FormConsumer>{tree => <Validator {...p} __tree={tree} />}</FormConsumer>\n    );\n  };\n}\n\nexport default validated;\n","import * as React from 'react';\nimport SchemaType from '../SchemaType';\nimport Widget from './Widget';\nimport validator from '../Decorators/validator';\n\nimport { Schema, Action } from '../../../typings/types';\nimport { FormContext } from '../../Store';\n\ntype Props = {\n  schema: Schema.Object;\n  status: { [key: string]: {} };\n  dispatch: (action: Action, ...args: ({} | undefined)[]) => any;\n  editKey: string;\n  __tree: FormContext;\n  value: {\n    [key: string]: {};\n  };\n  path: string[];\n  onChange: (value: {}) => void;\n};\n/**\n * Get schema from properties field\n * @param schema Object's schema\n * @param prop prop to get schema for\n */\nfunction schemaFromProperties(schema: Schema.Object, prop: string) {\n  const { properties = {} } = schema;\n  if (prop in properties) {\n    return properties[prop];\n  }\n}\n/**\n * Retrieve **first** matching schema from patternProperties\n * @param schema Object's schema\n * @param prop prop to get schema for\n */\nfunction schemaFromPattern(schema: Schema.Object, prop: string) {\n  const patternProperties = schema.patternProperties || {};\n  const patterns = Object.keys(patternProperties);\n  const p = patterns.find(p => new RegExp(p).test(prop));\n  if (p) {\n    return patternProperties[p];\n  }\n}\n/**\n * Get schema for a given property\n * @param schema Object's schema\n * @param prop prop to get schema for\n */\nfunction schemaForProp(schema: Schema.Object, prop: string) {\n  return (\n    schemaFromProperties(schema, prop) ||\n    schemaFromPattern(schema, prop) ||\n    schema.additionalProperties\n  );\n}\nconst EMPTY_OBJECT = {};\n\nclass ObjectField extends React.Component<Props> {\n  keys = new Map<string, string>();\n  keyId = 0;\n  renderChildren(props: Props) {\n    const children = [];\n    const properties = props.schema.properties || {};\n    const value: { [key: string]: {} } = props.value || {};\n    // Holds schema properties and value properties missing from schema.\n    const mergedProperties: Array<string> = Object.keys(properties);\n\n    Object.keys(value).forEach(v => {\n      if (v in properties) {\n        return;\n      }\n      mergedProperties.push(v);\n    });\n    function indexFor(property: string): number {\n      if (properties[property]) {\n        const index = properties[property].index;\n        if (typeof index === 'number') {\n          return index;\n        }\n      }\n      return 0;\n    }\n    // Index based sorting\n    function sortProperties(a: string, b: string): number {\n      return indexFor(a) - indexFor(b);\n    }\n\n    mergedProperties.sort(sortProperties);\n    const keys = new Map<string, string>();\n    for (let i: number = 0; i < mergedProperties.length; i += 1) {\n      const prop: string = mergedProperties[i];\n      const propSchema = schemaForProp(props.schema, prop);\n      if (!this.keys.has(prop)) {\n        keys.set(prop, String(this.keyId++));\n      } else {\n        keys.set(prop, this.keys.get(prop)!);\n      }\n      children.push(\n        <SchemaType\n          {...props}\n          status={props.status[prop] || EMPTY_OBJECT}\n          schema={propSchema}\n          value={value[prop]}\n          editKey={prop}\n          key={keys.get(prop)}\n        />,\n      );\n    }\n    this.keys = keys;\n    return children;\n  }\n\n  addKey = (key: string, value?: unknown): void => {\n    if (typeof this.props.value === 'object' && key in this.props.value) {\n      throw new Error(`Property \"${key}\" already exists`);\n    }\n    this.keys.set(key, String(this.keyId++));\n    this.props.onChange(\n      Object.assign({}, this.props.value, {\n        [key]: value,\n      }),\n    );\n  };\n  removeKey = (key: string): void => {\n    const value: { [key: string]: {} } = Object.assign({}, this.props.value);\n    delete value[key];\n    this.keys.delete(key);\n    this.props.onChange(value);\n  };\n  alterKey = (key: string, newKey: string): void => {\n    if (key === newKey) {\n      return;\n    }\n    if (newKey in this.props.value) {\n      throw new Error(`Property \"${newKey}\" already exists`);\n    }\n    const value: { [key: string]: {} } = {};\n    Object.keys(this.props.value).forEach(p => {\n      if (p !== key) {\n        value[p] = this.props.value[p];\n      } else {\n        value[newKey] = this.props.value[p];\n      }\n    });\n    const currentElementKey = this.keys.get(key);\n    this.keys.delete(key);\n    this.keys.set(newKey, currentElementKey!);\n    this.props.onChange(value);\n  };\n  render() {\n    return (\n      <Widget\n        {...this.props}\n        addKey={this.addKey}\n        removeKey={this.removeKey}\n        alterKey={this.alterKey}\n      >\n        {this.renderChildren(this.props)}\n      </Widget>\n    );\n  }\n}\nexport default validator(ObjectField);\n","import * as React from 'react';\nimport Widget from './Widget';\nimport validator from '../Decorators/validator';\n\nimport { Schema, Action } from '../../../typings/types';\nimport { FormContext } from '../../Store';\n\ntype Props = {\n  schema: Schema & { type: 'number' | 'string' };\n  value?: number | string;\n  editKey: string;\n  path: string[];\n  __tree: FormContext;\n  onChange: (value: string | number) => void;\n  dispatch: (action: Action, ...args: {}[]) => any;\n};\n\nfunction StringField(props: Props) {\n  return <Widget {...props} />;\n}\n\nexport { StringField as SimpleStringField };\nexport default validator<Props>(StringField);\n","import * as React from 'react';\nimport validator from '../Decorators/validator';\nimport { SimpleStringField } from './String';\nimport { Schema, Action } from '../../../typings/types';\nimport { FormContext } from '../../Store';\n\ninterface Props {\n  schema: Schema & { type: 'number' | 'string' };\n  value?: number;\n  editKey: string;\n  path: string[];\n  __tree: FormContext;\n  dispatch: (action: Action, ...args: {}[]) => any;\n  onChange: (value: string | void | number) => void;\n}\n/**\n * Transform to numeric value or undefined. Used to compare exp,\n * binary, hexa, ... strings\n * @param value value to convert\n */\nfunction toNumber(value?: string | number) {\n  switch (typeof value) {\n    case 'number':\n      return value;\n    case 'string':\n      return value === '' ? undefined : Number(value);\n    default:\n      return undefined;\n  }\n}\nclass NumberField extends React.Component<Props, { value?: string | number }> {\n  static getDerivedStateFromProps = (\n    props: Props,\n    state: { value?: string | number },\n  ) => {\n    if (toNumber(state.value) !== toNumber(props.value)) {\n      return {\n        value: props.value,\n      };\n    }\n    return null;\n  };\n  state = { value: this.props.value };\n  onChange = (val?: string | number) => {\n    const value: string | number | undefined = val === '' ? undefined : val;\n    const numVal = Number(value);\n    this.setState(\n      {\n        value,\n      },\n      () => this.props.onChange(isNaN(numVal) ? value : numVal),\n    );\n  };\n  render() {\n    return (\n      <SimpleStringField\n        {...this.props}\n        value={this.state.value}\n        onChange={this.onChange}\n      />\n    );\n  }\n}\nexport default validator<Props>(NumberField);\n","import * as React from 'react';\nimport Widget from './Widget';\nimport validator from './../Decorators/validator';\n\nimport { Schema, Action } from '../../../typings/types';\nimport { FormContext } from '../../Store';\ninterface Props {\n  schema: Schema & { type: 'boolean' };\n  editKey: string;\n  path: string[];\n  __tree: FormContext;\n  value: boolean;\n  onChange: (value?: boolean) => void;\n  dispatch: (action: Action, ...args: {}[]) => any;\n}\nfunction BooleanField(props: Props) {\n  return <Widget {...props} />;\n}\n\nexport default validator(BooleanField);\n","import * as React from 'react';\nimport SchemaType from '../SchemaType';\nimport Widget from './Widget';\nimport validator from '../Decorators/validator';\n\nimport { Schema, Action } from '../../../typings/types';\nimport { FormContext } from '../../Store';\n\ntype Props = {\n  onChange: (val: {}[]) => void;\n  schema: Schema.Array;\n  dispatch: (action: Action, ...args: ({} | undefined)[]) => any;\n  value?: {}[];\n  __tree: FormContext;\n  editKey: string;\n  status: { [key: string]: {} };\n  path: string[];\n  [key: string]: any;\n};\nconst EMPTY_OBJECT = {};\n\nfunction onChildRemove(props: Props) {\n  return function onRemove(index: number) {\n    const oldValue = props.value || [];\n    props.onChange(oldValue.filter((e, i) => Number(i) !== Number(index)));\n  };\n}\n\nfunction onChildAdd(props: Props) {\n  return function onAdd(value?: {}) {\n    const oldValue = props.value || [];\n    props.onChange(oldValue.concat([value]));\n  };\n}\n\nfunction renderChildren(props: Props) {\n  const {\n    value,\n    schema: { items },\n  } = props;\n  let valueItems: {}[];\n  if (value) {\n    valueItems = value;\n  } else {\n    valueItems = [];\n  }\n  const children: JSX.Element[] = [];\n  valueItems.forEach((val, i) =>\n    children.push(\n      <SchemaType\n        {...props}\n        schema={Array.isArray(items) ? items[i] || {} : items}\n        value={val}\n        editKey={String(i)}\n        status={props.status[String(i)] || EMPTY_OBJECT}\n        key={i}\n      />,\n    ),\n  );\n  return children;\n}\n\nfunction ArrayField(props: Props) {\n  return (\n    <Widget\n      {...props}\n      onChildAdd={onChildAdd(props)}\n      onChildRemove={onChildRemove(props)}\n    >\n      {renderChildren(props)}\n    </Widget>\n  );\n}\n\nexport default validator<Props>(ArrayField);\n","import ObjectField from './Object';\nimport StringField from './String';\nimport NumberField from './Number';\nimport BooleanField from './Boolean';\nimport ArrayField from './Array';\n\nexport default {\n  object: ObjectField,\n  string: StringField,\n  number: NumberField,\n  boolean: BooleanField,\n  array: ArrayField,\n};\n","import * as React from 'react';\n\nimport { WidgetProps } from '../../../typings/types';\n\nfunction Undefined(props: WidgetProps) {\n  return (\n    <div>{`Undefined field type \"${props.schema.type!.toString()}\", [${props.path.toString()}]`}</div>\n  );\n}\n\nexport default Undefined;\n","export default function infer(value?: {} | undefined | null) {\n  switch (typeof value) {\n    case 'number':\n      return 'number';\n    case 'string':\n      return 'string';\n    case 'boolean':\n      return 'boolean';\n    case 'object':\n      return Array.isArray(value) ? 'array' : 'object';\n    default:\n      return 'string';\n  }\n}\n","import * as React from 'react';\nimport { cloneDeep, isEqual } from 'lodash-es';\nimport { setDefaultValue } from '../../Store/actions';\nimport { Action, Schema } from '../../../typings/types';\n\nexport type Props = {\n  editKey?: string;\n  path: string[];\n  status: {\n    $$$state?: string;\n  };\n  value?: {};\n  schema: Schema;\n  dispatch: (action: Action, ...args: ({} | undefined)[]) => any;\n};\nfunction updateDefault({\n  value,\n  schema: { value: defaultValue },\n  dispatch,\n  path,\n}: Props) {\n  const val = value !== undefined ? value : cloneDeep(defaultValue);\n  if (val !== value) {\n    dispatch(setDefaultValue, path, val);\n  }\n  return val;\n}\n\nfunction fromDefaultValue<P extends Props>(Comp: React.ComponentType<P>) {\n  class DefaultValue extends React.Component<P, { val?: {}; init: boolean }> {\n    static getDerivedStateFromProps(nextProps: P, state: { init: boolean }) {\n      const {schema, value, dispatch, path} = nextProps\n      if(\"const\" in schema && !isEqual(schema.const, value)){\n        const val = cloneDeep(schema.const);\n        dispatch(setDefaultValue, path, val);\n        return {val};\n      }\n      if (state.init) {\n        return { init: false };\n      }\n      return {\n        val: nextProps.value,\n      };\n    }\n    state = { val: updateDefault(this.props), init: true };\n    render() {\n      return <Comp {...this.props} value={this.state.val} />;\n    }\n  }\n\n  return DefaultValue;\n}\n\nexport default fromDefaultValue;\n","import * as React from 'react';\nimport Fields from './Fields/index';\nimport visible from './Decorators/visible';\nimport UndefinedField from './Fields/Undefined';\nimport inference from './Decorators/inference';\nimport fromDefaultValue from './Decorators/fromDefaultValue';\nimport { update, destroy } from '../Store/actions';\n\nimport { Schema, Action, TYPESTRING } from '../../typings/types';\n\ntype SchemaProps = {\n  schema: Schema;\n  status: { [key: string]: {} };\n  path: string[];\n  dispatch: (action: Action, ...args: ({} | undefined)[]) => any;\n  editKey?: string;\n  value?: {};\n  context?: {};\n};\n\n/**\n * Component generating the correct field based on schema.type\n * @constructor\n * @param {Object} props\n */\nclass SchemaType<P extends SchemaProps> extends React.Component<P> {\n  static defaultProps = {\n    path: [],\n  };\n  constructor(props: P) {\n    super(props);\n    this.onChange = this.onChange.bind(this);\n  }\n  onChange(...args: {}[]) {\n    this.props.dispatch(update, this.props.path, ...args);\n  }\n  componentWillUnmount() {\n    this.props.dispatch(destroy, this.props.path);\n  }\n  render() {\n    const {\n      schema: { type },\n    } = this.props;\n    const renderType = Array.isArray(type)\n      ? (type as TYPESTRING[]).find(t => t !== 'null')\n      : type;\n    let Type: React.ComponentType<any>;\n    if (renderType === undefined || renderType === 'null') {\n      Type = UndefinedField;\n    } else {\n      Type = Fields[renderType];\n    }\n    if (Type === undefined) {\n      Type = UndefinedField;\n    }\n    return <Type {...this.props} onChange={this.onChange} />;\n  }\n}\nexport default inference(fromDefaultValue(visible(SchemaType)));\n","import * as React from 'react';\nimport { Action, Schema } from '../../../typings/types';\nimport { FormConsumer } from '../../Store';\n\ntype Props = {\n  schema: Schema;\n  path: string[];\n  value?: {};\n  dispatch: (action: Action, ...args: {}[]) => any;\n};\nfunction visibility<P extends Props>(\n  Comp: React.ComponentType<P>,\n): React.FunctionComponent<P> {\n  return function Visible(props: P) {\n    const {\n      schema: { visible },\n      value,\n    } = props;\n\n    return (\n      <FormConsumer>\n        {({ value: formValue }) => {\n          try {\n            if (\n              visible &&\n              !visible(\n                value,\n                formValue,\n                props.path.concat(), // Copy\n              )\n            ) {\n              return null!;\n            }\n          } catch (e) {\n            return null!;\n          }\n          return <Comp {...props} />;\n        }}\n      </FormConsumer>\n    );\n  };\n}\n\nexport default visibility;\n","import * as React from 'react';\nimport infer from './../../Utils/infer';\nimport { Schema } from '../../../typings/types';\n/**\n * Update store's value path.\n * @param {Array<string>} currentValuePath the valuePath the parent\n * @param {string} editKey the key currently edited\n * @returns {Array<string>}the updated valuePath\n */\nfunction updatePath(currentPath: string[], editKey?: string): string[] {\n  if (editKey !== undefined) {\n    return currentPath.concat([editKey]);\n  }\n  return currentPath;\n}\ninterface InferProps {\n  path: string[];\n  editKey?: string;\n  value?: {};\n  schema: Schema;\n}\ninterface InferState {\n  schema: Schema;\n  path: string[];\n  oldPath?: string[];\n  oldEditKey?: string;\n  oldValue?: {};\n}\n/**\n * Remove specified keys.\n */\ntype Omit<Type, Keys extends keyof Type> = Pick<\n  Type,\n  Exclude<keyof Type, Keys>\n>;\n\n/**\n * Make specified key optional. Others don't change.\n */\ntype PartialKey<Type, Keys extends keyof Type> = Omit<Type, Keys> &\n  Partial<Pick<Type, Keys>>;\n\n/**\n * HOC, compute schema value from inferred type if schema is missing\n * @param Comp component to decorate.\n * @return the decorated component.\n */\nfunction inference<P extends InferProps>(Comp: React.ComponentType<P>) {\n  type PartialSchemaProps = PartialKey<P, 'schema'>;\n  class Infer extends React.Component<PartialSchemaProps, InferState> {\n    state: InferState = {\n      path: [],\n      schema: {},\n    };\n    static getDerivedStateFromProps(\n      nextProps: PartialSchemaProps,\n      curState: InferState,\n    ): Partial<InferState> {\n      let nextState: Partial<InferState> = {};\n      if (\n        curState.oldEditKey !== nextProps.editKey ||\n        curState.oldPath !== nextProps.path\n      ) {\n        nextState.path = updatePath(nextProps.path, nextProps.editKey);\n        nextState.oldPath = nextProps.path;\n        nextState.oldEditKey = nextProps.editKey;\n      }\n      if (\n        curState.schema !== nextProps.schema ||\n        infer(nextProps.value) !== infer(curState.oldValue)\n      ) {\n        let inferredSchema = nextProps.schema || {};\n        if (!('type' in inferredSchema)) {\n          inferredSchema = {\n            type: infer(nextProps.value),\n            ...inferredSchema,\n          };\n        }\n        nextState.schema = inferredSchema;\n        // nextState.oldSchema = nextProps.schema;\n      }\n      return nextState;\n    }\n\n    render() {\n      const { type } = this.state.schema;\n      return (\n        // @ts-ignore https://github.com/Microsoft/TypeScript/issues/28748\n        <Comp\n          // Recreate component on type change\n          key={Array.isArray(type) ? undefined : type}\n          {...this.props}\n          path={this.state.path}\n          schema={this.state.schema}\n        />\n      );\n    }\n  }\n  return Infer;\n}\n\nexport default inference;\n","import * as React from 'react';\nimport { Store } from '../Store/index';\nimport SchemaType from './SchemaType';\nimport validate from './../Utils/customValidator';\nimport { setValidationErrors } from '../Store/actions';\n\nimport { Schema } from '../../typings/types';\n\nconst EMPTY_ARRAY: any[] = [];\n\nexport type Props = {\n  onChange: (value: {} | undefined, errors: {}[]) => void;\n  schema: Schema;\n  context?: {};\n  value?: {};\n};\n/**\n * Top Component\n */\nclass Container extends React.Component<Props> {\n  store: Store | null = null;\n  static defaultProps = { schema: {} };\n  getValue() {\n    return this.store!.state.value;\n  }\n  update = (value: {} | undefined) => {\n    this.props.onChange(\n      value,\n      validate(value, this.props['schema'], value).errors,\n    );\n  };\n  validate() {\n    const validationResult = validate(\n      this.store!.state.value,\n      this.store!.state.schema,\n      this.store!.state.value,\n    );\n    this.store!.dispatch(setValidationErrors, [], validationResult.errors);\n    return validationResult.errors;\n  }\n  render() {\n    return (\n      <Store\n        ref={s => {\n          this.store = s;\n        }}\n        value={this.props.value}\n        schema={this.props.schema}\n        context={this.props.context}\n        onValueChange={this.update}\n      >\n        {({ schema, value, status, dispatch, context}) => (\n          <SchemaType\n            schema={schema}\n            context={context}\n            dispatch={dispatch}\n            value={value}\n            path={EMPTY_ARRAY}\n            status={status}\n          />\n        )}\n      </Store>\n    );\n  }\n}\n\nexport default Container;\n"],"names":["FormContext","React","createContext","value","undefined","schema","context","status","FormConsumer","Consumer","Store","extValue","oldProps","action","args","setState","prevState","immer","getDerivedStateFromProps","nextProps","state","ret","shouldComponentUpdate","nextState","this","componentDidUpdate","prevProps","props","_this2","onValueChange","render","cloneValue","JSON","parse","stringify","Provider","children","dispatch","Component","DefaultWidget","defaultWidget","type","undefinedWidgetFactory","setDefaultWidgets","obj","Object","assign","EMPTYOBJECT","Widget","view","formVal","__tree","forwardProps","editKey","path","onChange","onChildAdd","onChildRemove","addKey","removeKey","alterKey","errorMessage","Wdgt","_Wdgt","formValue","Type","renderType","Array","isArray","find","t","customValidator","jsonschema","Validator","validate","basePath","ctx","attributes","errored","instance","options","SchemaError","concat","propertyPath","split","slice","msg","VALUE","STATUS","NO_ERRORS","setErrors","errors","errorPath","setWith","setValidationErrors","errorMap","Map","forEach","error","get","property","push","message","set","key","filter","x","update","statusPath","setDefaultValue","destroy","unset","e","getErrors","validated","Comp","val","validation","_this","p","tree","schemaForProp","prop","properties","schemaFromProperties","patternProperties","keys","RegExp","test","schemaFromPattern","additionalProperties","EMPTY_OBJECT","validator","Error","String","keyId","newKey","currentElementKey","renderChildren","mergedProperties","indexFor","index","v","sort","a","b","i","length","propSchema","has","SchemaType","StringField","toNumber","Number","NumberField","numVal","isNaN","SimpleStringField","oldValue","object","ObjectField","string","number","BooleanField","array","items","Undefined","toString","infer","updateDefault","defaultValue","cloneDeep","bind","componentWillUnmount","UndefinedField","Fields","curState","currentPath","oldEditKey","oldPath","inferredSchema","inference","init","isEqual","fromDefaultValue","visible","EMPTY_ARRAY","Container","getValue","store","validationResult","ref","s"],"mappings":"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"}